#!/usr/bin/env node

const pkg = require('../package.json');
const fileStore = require('./fileStore');
const fs = require('fs');
const fse = require('fs-extra');
const log = require('./log');
const path = require('path');
const forkProcess = require('./forkProcess');
const styles = require('./styles');
const transpiler = require('./transpiler');
const watch = require('watch');
const { escapeRegExp, isJs, isServerFile, isClientFile, getClientEnv, isSharedFile, getTime } = require('./utils');
const debounce = require('lodash.debounce');

const cwd = process.cwd();

// --------------------------------------------------------------------------
// Tools configuration
// --------------------------------------------------------------------------

const babelOptions = JSON.parse(fs.readFileSync(path.join(cwd, '.babelrc')));

const watchOptions = {
  ignoreDotFiles: true,
  ignoreUnreadableDir: true,
  ignoreNotPermitted: true,
  interval: 0.25,
};

const browserifyOptions = {
  debug: true,
  fullPaths: false,
};

const sassOptions = {
  outputStyle: 'compressed',
  sourceMap: true,
  sourceMapEmbed: true,
};

// --------------------------------------------------------------------------
// config / paths
// --------------------------------------------------------------------------

// js stuff
const srcDirectory = path.join(cwd, 'src');
const srcRegExp = new RegExp('^' + escapeRegExp(srcDirectory));

const distDirectory = path.join(cwd, 'dist');
const distRegExp = new RegExp('^' + escapeRegExp(distDirectory));

// this file define the env in which the clients should run ('node' or 'browser')
const clientEnvFile = path.join(distDirectory, 'client', 'env.json');

const clientPublicDirectory = path.join(cwd, 'public', 'js');
const sassSrcDirectory = path.join(cwd, 'sass');
const cssPublicDirectory = path.join(cwd, 'public', 'css');

const additionnalWatchDirectories = [
  path.join(cwd, 'node_modules', 'soundworks', 'client'),
  path.join(cwd, 'node_modules', 'soundworks', 'server'),
  path.join(cwd, 'node_modules', 'soundworks', 'thing'),
];


// match and test client names
const escapedClientsMatchStr = '^' + escapeRegExp(distDirectory + path.sep + 'client' + path.sep) + '([a-zA-Z\-_]+)' + escapeRegExp(path.sep + 'index.js');
const clientIndexesMatch = new RegExp(escapedClientsMatchStr);

const escapedClientsSearchStr = '^' + escapeRegExp(distDirectory + path.sep + 'client' + path.sep) + '([a-zA-Z\-_]+)' + escapeRegExp(path.sep) + '.*';
const clientNameSearch = new RegExp(escapedClientsSearchStr);

// --------------------------------------------------------------------------
// reusable logic
// --------------------------------------------------------------------------

/**
 * transpile files (babel)
 */
async function transpileOrCopy(filename) {
  const src = await fileStore.get(filename);
  const distFilename = src.abs.replace(srcRegExp, distDirectory);
  const dist = await fileStore.get(distFilename);
  const startTime = getTime();

  if (!isJs(src)) {
    try {
      fse.copySync(src.abs, dist.abs);
      log.copyFileSuccess(src, dist, getTime(startTime));

      return Promise.resolve([src, dist]);
    } catch(err) {
      log.copyFileError(src, err);
      return Promise.reject([src, dist]);
    }
  } else {
    try {
      await transpiler.transpile(src, dist, babelOptions);
      log.transpileSuccess(src, dist, getTime(startTime));

      return Promise.resolve([src, dist]);
    } catch(err) {
      log.transpileError(src, err);
      return Promise.reject([src, dist]);
    }
  }
}

async function transpileOrCopyAll() {
  const files = await fileStore.getAll(srcDirectory);
  const pairs = [];

  for (let i = 0; i < files.length; i++) {
    try {
      const src = files[i];
      const pair = await transpileOrCopy(src);
      pairs.push(pair);
    } catch(err) {
      console.log(err.stack);
    }
  }

  return pairs;
}

/**
 * bundle files (browserify)
 */
async function bundle(src) {
  const clientName = src.abs.match(clientIndexesMatch)[1];
  const bundleTarget = path.join(clientPublicDirectory, `${clientName}.js`);
  const dist = await fileStore.get(bundleTarget);
  const startTime = getTime();

  try {
    await transpiler.bundle(src, dist, browserifyOptions);
    log.bundleSuccess(src, dist, getTime(startTime));
    return Promise.resolve([src, dist]);
  } catch(err) {
    log.bundleError(src, getTime(startTime));
    return Promise.reject([src, dist]);
  }
}

async function bundleAll() {
  try {
    const files = await fileStore.getAll(distDirectory);
    const indexes = files.filter(file => {
      const matches = file.abs.match(clientIndexesMatch);
      let isBrowserClient = false;

      if (matches !== null) {
        const clientName = matches[1];

        if (getClientEnv(clientName, clientEnvFile) === 'browser') {
          isBrowserClient = true;
        }
      }

      return isBrowserClient;
    });

    return Promise.all(indexes.map(bundle));
  } catch(err) {
    return Promise.reject();
  }
}

/**
 * proces sass
 */
async function processSass() {
  const sassFiles = await fileStore.getAll(sassSrcDirectory);
  const sassEntryPoints = sassFiles.filter(src => !/^_/.test(path.basename(src.abs)))

  const pairs = await Promise.all(sassEntryPoints.map(async function(src) {
    const basename = path.basename(src.abs, '.scss');
    const cssFilename = path.join(cssPublicDirectory, basename + '.css');
    const dist = await fileStore.get(cssFilename);
    return [src, dist];
  }));

  return Promise.all(pairs.map(async function([src, dist]) {
    const startTime = getTime();

    try {
      await styles.process(src, dist, sassOptions);
      log.sassSuccess(src, dist, getTime(startTime));
      return Promise.resolve([src, dist]);
    } catch(err) {
      log.sassError(src, err);
      return Promise.reject(src);
    }
  }));
}

async function restartProcess(processName) {
  const filename = path.join(distDirectory, processName, 'index.js');
  const file = await fileStore.get(filename);

  try {
    const stopped = await forkProcess.stop(file);
    if (stopped) {
      log.processStop(processName);
    }

    await forkProcess.start(file);
    log.processStart(processName);
    return Promise.resolve(file);
  } catch(err) {
    log.processError(processName, err);
    return Promise.reject(file);
  }
}

async function deleteFile(file) {
  try {
    fileStore.delete(file);
    log.deleteFileSuccess(file);
    return Promise.resolve(file);
  } catch(err) {
    log.deleteFileError(file, err)
    return Promise.reject(file);
  }
}

async function handleWatchDistChange(filename) {
  const dist = await fileStore.get(filename);

  try {
    if (isSharedFile(dist)) {
      if (isClientFile(dist)) {
        await bundleAll();
      } else if (isServerFile(dist)) {
        await restartProcess('server');
      } else {
        await bundleAll();
        await restartProcess('server');
      }
    } else if (isClientFile(dist)) {
      const matches = dist.abs.match(clientNameSearch);

      if (matches !== null) {
        const clientName = matches[1];
        const clientEnv = getClientEnv(clientName, clientEnvFile);

        if (clientEnv === 'browser') {
          const index = path.join(distDirectory, 'client', clientName, 'index.js');
          const dist = await fileStore.get(index);
          await bundle(dist);
        } else if (clientEnv === 'node') {
          // do nothing
        }
      }
    } else if (isServerFile(dist)) {
      await restartProcess('server');
    }
  } catch (err) {
    console.error(err.stack);
  }
}

// const deleteFile = file => {
//   return fileStore
//     .delete(file)
//     .then(log.deleteFileSuccess)
//     .catch(err => log.deleteFileError(file, err));
// };

// -------------------------------------------------------------
// Watch functions
// -------------------------------------------------------------

function watchCss() {
  watch.createMonitor(sassSrcDirectory, Object.assign({}, watchOptions), monitor => {
    monitor.on('created', processSass);
    monitor.on('changed', processSass);
    monitor.on('removed', processSass);
  });
}

function watchSrc() {
  watch.createMonitor(srcDirectory, Object.assign({}, watchOptions), monitor => {
    monitor.on('created', transpileOrCopy);
    monitor.on('changed', transpileOrCopy);
    // delete dist file
    monitor.on('removed', async (filename, stats) => {
      const distFilename = filename.replace(srcRegExp, distDirectory);
      const dist = await fileStore.get(distFilename).then();
      await deleteFile(dist);
    });
  });
}

function watchDist() {
  watch.createMonitor(distDirectory, Object.assign({}, watchOptions), monitor => {
    monitor.on('created', handleWatchDistChange);
    monitor.on('changed', handleWatchDistChange);
    monitor.on('removed', handleWatchDistChange);
  });

  async function onAdditionnalChange() {
    try {
      await bundleAll();
      await restartProcess('server');
    } catch(err) {
      console.error(err.stack);
    }
  }

  additionnalWatchDirectories.forEach(dir => {
    watch.createMonitor(dir, Object.assign({}, watchOptions), monitor => {
      monitor.on('created', onAdditionnalChange);
      monitor.on('changed', onAdditionnalChange);
      monitor.on('removed', onAdditionnalChange);
    });
  });
}

function watchDistClientProcess(processName) {
  const watchDir = path.join(distDirectory, 'client', processName);
  async function restart() { await restartProcess(`client/${processName}`); }

  watch.createMonitor(watchDir, Object.assign({}, watchOptions), monitor => {
    monitor.on('created', restart);
    monitor.on('changed', restart);
    monitor.on('removed', restart);
  });

  additionnalWatchDirectories.forEach(dir => {
    watch.createMonitor(dir, Object.assign({}, watchOptions), monitor => {
      monitor.on('created', restart);
      monitor.on('changed', restart);
      monitor.on('removed', restart);
    });
  });
}

// -------------------------------------------------------------
// Commands
// -------------------------------------------------------------

function __watch() {
  try {
    watchSrc();
    watchCss();
    watchDist();
    restartProcess('server');

    return Promise.resolve();
  } catch(err) {
    return Promise.reject(err);
  }
}

function __watchThing(processName = 'thing') {
  try {
    watchDistClientProcess(processName);
    restartProcess(`client/${processName}`);
    return Promise.resolve();
  } catch(err) {
    return Promise.reject(err);
  }
}

async function __transpile() {
  try {
    const transpiledSass = await processSass();
    const transpiledJS = await transpileOrCopyAll();
    const bundleFiles = await bundleAll();

    return Promise.resolve();
  } catch(err) {
    return Promise.reject(err);
  }
}

function __start() {
  try {
    restartProcess('server');
    return Promise.resolve();
  } catch(err) {
    return Promise.reject(err);
  }
}

/**
 * minify all client files (uglify.js)
 */
async function __minify(file) {
  async function minifyClient(src) {
    const minifyTarget = src.abs.replace(/\.js$/, '.min.js');
    const dist = await fileStore.get(minifyTarget);
    const startTime = getTime();

    try {
      await transpiler.minify(src, dist);
      log.minifySuccess(src, dist, getTime(startTime));
      return Promise.resolve();
    } catch(err) {
      log.minifyError(src, err);
      return Promise.reject(src, err);
    }
  }

  try {
    const files = await fileStore.getAll(clientPublicDirectory);
    const minFiles = files.filter(file => /\.min\.js$/.test(file.abs));
    await Promise.all(minFiles.map(fileStore.delete));

    const jsFiles = files.filter(file => !/\.min\.js$/.test(file.abs) && /\.js$/.test(file.abs));
    await Promise.all(jsFiles.map(minifyClient));
    return Promise.resolve();
  } catch(err) {
    return Promise.reject(err);
  }
}

/**
 * clean project
 */
async function __clear() {
  const directories = [
    await fileStore.get(distDirectory),
    await fileStore.get(clientPublicDirectory),
    await fileStore.get(cssPublicDirectory),
  ];

  directories.forEach(async function(dir) {
    try {
      await deleteFile(dir);
      return Promise.resolve();
    } catch(err) {
      return Promise.reject();
    }
  });
}

/* --------------------------------------------------------------------------
 * Parse commands
 * -------------------------------------------------------------------------- */

const cmd = process.argv[2];

switch (cmd) {
  case '--watch':
    __transpile().then(__watch).catch(err => console.error('Unhandled Error', err));
    break;
  case '--watch-thing':
    const thingName = process.argv[3];
    __transpile().then(() => __watchThing(thingName)).catch(err => console.error('Unhandled Error', err));
    break;
  case '--transpile':
    __transpile().catch(err => console.error(err.stack));
    break;
  case '--start':
    __start().catch(err => console.error('Unhandled Error', err));
    break;
  case '--minify':
    __minify().catch(err => console.error('Unhandled Error', err));;
    break;
  case '--clear': // ok
    __clear().catch(err => console.error(err.stack));;
    break;
  case '--help':
    console.log(`
[soundworks-template] available commands:

- \`npm run clear\`\tclean the project, delete \`dist/\`, \`public/css/\`, \`public/js\`
- \`npm run minify\`\tminify all client files with uglify.js
- \`npm run start\`\tstarts the server
- \`npm run transpile\`\ttranspile and bundle all sources (js and css)
- \`npm run watch\`\trun the server, and transpile, bundle, and restart server on file change
- \`npm run watch:thing [name]\`\trun a thing client, and relaunch it on file change

    `);
}

process.on('SIGINT', () => process.exit());

/* -------------------------------------------------------------------------- */

